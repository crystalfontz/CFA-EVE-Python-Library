#===========================================================================
#
# Crystalfontz Raspberry-Pi Python example library for FTDI / BridgeTek
# EVE graphic accelerators.
#
#---------------------------------------------------------------------------
#
# This file is part of the port/adaptation of existing C based EVE libraries
# to Python for Crystalfontz EVE based displays.
#
# THIS LIBRARY IS A WORK IN PROGRESS!
#
# 2021-10-20 Mark Williams / Crystalfontz America Inc.
# https:#www.crystalfontz.com/products/eve-accelerated-tft-displays.php
#---------------------------------------------------------------------------
#
# This is free and unencumbered software released into the public domain.
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
# For more information, please refer to <http:#unlicense.org/>
#
#============================================================================

import time
import importlib
from .cocmd import cocmd

class cfeve:
	def __init__(self, module_type, interface_type):
		#imports
		self.cocmd = cocmd(self)
		self.iface = importlib.import_module('.interface.'+interface_type, package='py_cfeve').iface()
		self.module = importlib.import_module('.module.'+module_type, package='py_cfeve')
		self.defs = importlib.import_module('.evedef.'+str(self.module.EVE_DEVICE), package='py_cfeve')

		#init vars
		self.LCD_WIDTH = self.module.LCD_WIDTH
		self.LCD_HEIGHT = self.module.LCD_HEIGHT
		self.EVE_DEVICE = self.module.EVE_DEVICE
		self.fifo_location = 0
		self.ramg_unused_start = 0
		self.dl_buffer = []
		self.cocmd_buffer = []

		#eve reset & wake up
		time.sleep(0.020)
		self.iface.eve_reset()
		self.host_command(0x00) #EVE_HCMD_ACTIVE
		time.sleep(0.040)
		#wait for REG_ID = 0x7C
		while self.iface.r8(self.defs.EVE_REG_ID) != 0x7C:
			print("waiting to read id = 0x7C")
			time.sleep(0.10)
		#wait for the self.defs.EVE_REG_CPURESET to indicate that all initializations are complete
		while self.iface.r8(self.defs.EVE_REG_CPURESET) != 0:
			print("waiting for reset to complete")
			time.sleep(0.10)
		#get and print chip id
		self.read_eve_id()
		#remind the chip of the speed it is running at
		self.iface.w32(self.defs.EVE_REG_FREQUENCY, self.module.EVE_CLOCK_SPEED)

		#early touch firmware inits
		if self.module.TOUCH_CAPACITIVE:
			#FT81x_Init_CTouch(host);
			pass
		if self.module.TOUCH_GOODIX_CAPACITIVE:
			#FT81x_Init_Goodix_GT911(host);
			pass

		#get initial write pointer location
		self.fifo_location = self.iface.r16(self.defs.EVE_REG_CMD_WRITE)

		#turn off screen & backlight
		self.iface.w8(self.defs.EVE_REG_PCLK, 0)
		self.iface.w8(self.defs.EVE_REG_PWM_DUTY, 0)

		# load parameters of the physical screen
		self.iface.w16(self.defs.EVE_REG_HSIZE, self.module.LCD_WIDTH)
		self.iface.w16(self.defs.EVE_REG_HCYCLE, self.module.LCD_HCYCLE)
		self.iface.w16(self.defs.EVE_REG_HOFFSET, self.module.LCD_HOFFSET)
		self.iface.w16(self.defs.EVE_REG_HSYNC0, self.module.LCD_HSYNC0)
		self.iface.w16(self.defs.EVE_REG_HSYNC1, self.module.LCD_HSYNC1)

		self.iface.w16(self.defs.EVE_REG_VSIZE, self.module.LCD_HEIGHT)
		self.iface.w16(self.defs.EVE_REG_VCYCLE, self.module.LCD_VCYCLE)
		self.iface.w16(self.defs.EVE_REG_VOFFSET, self.module.LCD_VOFFSET)
		self.iface.w16(self.defs.EVE_REG_VSYNC0, self.module.LCD_VSYNC0)
		self.iface.w16(self.defs.EVE_REG_VSYNC1, self.module.LCD_VSYNC1)

		self.iface.w8(self.defs.EVE_REG_SWIZZLE, self.module.LCD_SWIZZLE)
		self.iface.w8(self.defs.EVE_REG_PCLK_POL, self.module.LCD_PCLKPOL)

		self.iface.w8(self.defs.EVE_REG_CSPREAD, self.module.LCD_PCLK_CSPREAD)
		self.iface.w8(self.defs.EVE_REG_DITHER, self.module.LCD_DITHER)

		#setup gpiox drive strength
		gpiox = self.iface.r16(self.defs.EVE_REG_GPIOX)
		if self.module.LCD_DRIVE_10MA == 1:
  			#Set 10mA drive for: PCLK, DISP , VSYNC, HSYNC, DE, RGB lines & BACKLIGHT
			gpiox = gpiox | 0x1000
		else:
			#Set 5mA drive for: PCLK, DISP , VSYNC, HSYNC, DE, RGB lines & BACKLIGHT
			gpiox = gpiox & ~0x1000
		self.iface.w16(self.defs.EVE_REG_GPIOX, gpiox)

		#touch configuration
		if self.module.TOUCH_RESISTIVE:
			#resistive touch panel
			self.iface.w16(self.defs.EVE_REG_TOUCH_RZTHRESH, 1200)
			self.iface.w8(self.defs.EVE_REG_TOUCH_MODE, self.defs.EVE_TOUCHMODE_FRAME)
			#self.iface.w8(self.defs.EVE_REG_TOUCH_ADC_MODE, 0x01)
			#self.iface.w8(self.defs.EVE_REG_TOUCH_OVERSAMPLE, 15)
			self.iface.w8(self.defs.EVE_REG_TOUCH_OVERSAMPLE, 6)

		elif self.module.TOUCH_CAPACITIVE or self.module.TOUCH_GOODIX_CAPACITIVE:
			#cap touch panel
			self.iface.w8(self.defs.EVE_REG_TOUCH_MODE, self.defs.EVE_CTOUCH_MODE_COMPATIBILITY)
  			#Set compatibility (single touch) mode until after touch cal.
  			#Gpu_Hal_Wr8(host, REG_CTOUCH_EXTEND, CTOUCH_EXTEND_COMPATIBILITY);

		else:
			#disable touch completley
			self.iface.w8(self.defs.EVE_REG_TOUCH_MODE, 0)
			#eliminate any false touches
			self.iface.w16(self.defs.EVE_REG_TOUCH_RZTHRESH, 0)

		#clear the lcd
		self.iface.w32(self.defs.EVE_RAM_DL + 0, self.defs.EVE_ENC_CLEAR_COLOR_RGB(0, 0, 0))
		self.iface.w32(self.defs.EVE_RAM_DL + 4, self.defs.EVE_ENC_CLEAR(1, 1, 1))
		self.iface.w32(self.defs.EVE_RAM_DL + 8, self.defs.EVE_ENC_DISPLAY())
		self.iface.w8(self.defs.EVE_REG_DLSWAP, self.defs.EVE_DLSWAP_FRAME)

		#enable the DISP line of the LCD
		gpiox = self.iface.r16(self.defs.EVE_REG_GPIOX)
		self.iface.w16(self.defs.EVE_REG_GPIOX, gpiox | 0x8000)

		#now start clocking data to the LCD panel, enabling the display
		self.iface.w8(self.defs.EVE_REG_PCLK, self.module.LCD_PCLK)

		#backlight frequency default is 250Hz
		self.iface.w16(self.defs.EVE_REG_PWM_HZ, 500)
		#Crystalfontz EVE displays have soft start. No need to ramp.
		self.iface.w8(self.defs.EVE_REG_PWM_DUTY, 128)

		#get initial write pointer location again
		self.fifo_location = self.iface.r16(self.defs.EVE_REG_CMD_WRITE)

		#TODO: do any touch calibration here

		#done

#########################################################################################

	def host_command(self, command):
		data = [command & 0xFF, 0x00, 0x00]
		return self.iface.wr(data)

	def send_command(self, data):
		# send a command & update fifo location
		# data can be of type int or a list
		# note: there is no checking to make sure a command list
		#  will fit in the eve's buffer
		ret = self.iface.w32(self.fifo_location + self.defs.EVE_RAM_CMD, data)
		length = 1
		if isinstance(data, list):
			length = len(data)
		self.fifo_location += (self.defs.EVE_CMD_SIZE) * length
		self.fifo_location %= self.defs.EVE_RAM_CMD_SIZE
		return ret

	def fifo_free_space(self):
		cmdbuffer_rd = self.iface.r16(self.defs.EVE_REG_CMD_READ)
		cmdbuffer_wr = self.iface.r16(self.defs.EVE_REG_CMD_WRITE)
		cmdbuffer_diff = (cmdbuffer_wr - cmdbuffer_rd) % self.defs.EVE_RAM_CMD_SIZE
		return (self.defs.EVE_RAM_CMD_SIZE - self.defs.EVE_CMD_SIZE) - cmdbuffer_diff

	def fifo_wait(self, room):
		getfreespace = room - 1
		while getfreespace < room:
			getfreespace = self.fifo_freespace()
			time.sleep(0.005)

	def fifo_is_empty(self):
		cmdbuffer_rd = self.iface.r16(self.defs.EVE_REG_CMD_READ)
		cmdbuffer_wr = self.iface.r16(self.defs.EVE_REG_CMD_WRITE)
		if cmdbuffer_rd == cmdbuffer_wr:
			return True
		return False

	def fifo_wait_until_empty(self):
		#make the assumption that WR doesn't change while we wait
		#wont work for anything multi-threaded!
		#fast checking (small sleep time) chews CPU time!
		cmdbuffer_wr = self.iface.r16(self.defs.EVE_REG_CMD_WRITE)
		while self.iface.r16(self.defs.EVE_REG_CMD_READ) != cmdbuffer_wr:
			time.sleep(0.005)

	def update_fifo(self):
		# write the fifo location
		# causes the FT81x to process the command list
		return self.iface.w16(self.defs.EVE_REG_CMD_WRITE, self.fifo_location)

	def read_eve_id(self):
		#read
		#should be 0x08
		id = self.iface.r8(self.defs.EVE_CHIP_ID_ADDRESS)
		if id != 0x08:
			print("chip-id 0C0000h != 0x08")
			return False
		#should be 0x01
		id = self.iface.r8(self.defs.EVE_CHIP_ID_ADDRESS+2)
		if id != 0x01:
			print("chip-id 0C0002h != 0x01")
			return False
		#should be 0x00
		id = self.iface.r8(self.defs.EVE_CHIP_ID_ADDRESS+3)
		if id != 0x00:
			print("chip-id 0C0003h != 0x00")
			return False
		#get type
		type = self.iface.r8(self.defs.EVE_CHIP_ID_ADDRESS+1)
		print("chip-id = {}".format(hex(type)))
		return type

	def set_backlight(self, brightness):
		self.iface.w8(self.defs.EVE_REG_PWM_DUTY, brightness)

#########################################################################################

	def buffer_dl_add(self, command_list):
		#add command_list to display list buffer
		if len(self.dl_buffer) > (int(self.defs.EVE_RAM_DL_SIZE / 4)):
			print("display list buffer overflow!")
		else:
			self.dl_buffer.extend(command_list)
		#return

	def buffer_dl_length(self):
		#return display list buffer length
		return len(self.dl_buffer)

	def buffer_dl_flush(self):
		#send display list buffer to the EVE
		ret = self.iface.w32(self.defs.RAM_DL, self.dl_buffer)
		self.dl_buffer.clear()
		return ret

	def buffer_cocmd_add(self, command_list):
		#self.send_command(command_list)
		#add command_list to cmd list buffer
		if len(self.cocmd_buffer) > (int(self.defs.EVE_RAM_CMD_SIZE / 4)):
			print("command list buffer overflow!")
		else:
			if isinstance(command_list, int):
				self.cocmd_buffer.extend([command_list])
			elif isinstance(command_list, list) or isinstance(command_list, bytes):
				self.cocmd_buffer.extend(command_list)
		#return

	def buffer_cocmd_length(self):
		#return cmd list buffer length
		return len(self.cocmd_buffer)

	def buffer_cocmd_flush(self):
		#send cmd list buffer to the EVE
		#but we dont update the ring buffer pointer here
		ret = self.iface.w32(self.fifo_location + self.defs.EVE_RAM_CMD, self.cocmd_buffer)
		self.fifo_location += (self.defs.EVE_CMD_SIZE) * len(self.cocmd_buffer)
		self.fifo_location %= self.defs.EVE_RAM_CMD_SIZE
		self.cocmd_buffer.clear()
		return ret

##########################################################################################

	def get_ramg_end_addr(self):
		#get the end memory address of data inflated by CMD_INFLATE
		#make sure that the chip is caught up
		self.fifo_wait_until_empty()
		#tell the chip to get the first free location in RAM_G
		self.get_ptr()
		#update the ring buffer pointer so the graphics processor starts executing
		self.update_fifo()
		#wait for the chip to catch up
		self.fifo_wait_until_empty()
		#we know that the answer is 4 addresses lower than
		#read the value and pass it back to the caller know what we found
		ramg_end_addr = self.iface.r32(self.RAM_CMD + (self.fifo_location - 4) & 0x0FFF)
		return ramg_end_addr

	def infate_to_ramg(self, data, ramg_address):
		#inflate ZLIB deflated data into ramg at ramg_address
		#extend list to ensure 4-byte alignment
		data_length = (len(data) + 0x03) & 0xFFFFFFFC
		data.extend([0] * (data_length - len(data)))
		#load and inflate data from flash to RAM_G
		#write the self.defs.EVE_ENC_CMD_INFLATE and parameters
		self.send_command([self.defs.EVE_ENC_CMD_INFLATE, ramg_address])
		#pipe out data_length of data from data_address
		#use chunks so we can handle images larger than 4K
		data_position = 0
		while data_length != 0:
			#what is the maximum we can transfer in this block?
			#see how much room is available in the self.defs.EVE_RAM_CMD
			bytes_free = self.fifo_free_space()
			if data_length <= bytes_free:
				#everything will fit in the available space
				bytes_this_block = data_length
			else:
				#it won't all fit, transfer the maximum amount
				bytes_this_block = bytes_free - 4
			#set the address in self.defs.EVE_RAM_CMD for this block
			command_list = [self.defs.EVE_ENC_CMD_MEMWRITE]
			#add the data
			command_list += data[data_position:data_position+bytes_this_block]
			#send it
			self.send_command(command_list)
			#process the data
			self.update_fifo()
			#now wait for it to catch up
			self.fifo_wait_until_empty()

		#get the first free address in RAM_G from after the inflated data, and
		#push it into the caller's variable
		ramg_address = self.get_ramg_end_addr()
		#to be safe, force RAM_G_Address to be 8-byte aligned (maybe not needed, certainly does not hurt)
		ramg_address = (ramg_address + 0x07) & 0xFFFFFFF8
		#return the new ramg_address
		return ramg_address

	def write_blob_to_flash_sect0(self, first_unused_ramg_address, flash_sector):
		#wait until EVE is caught up
		self.fifo_wait_until_empty()
		#expand the flash_blob, keep track of how big it expands to
		end_ramg_address = self.infate_to_ramg(self.defs.EVE_FLASH_BLOB, first_unused_ramg_address)
		#now ask the EVE to program the 1st sector of flash with the expanded flash_blob sitting in RAMG at
		command_list = [self.defs.EVE_ENC_CMD_FLASHUPDATE,
			#destination in flash (must be 4096 byte aligned)
			flash_sector * 4096,
			#source in RAM_G (must be 4-byte aligned)
			first_unused_ramg_address,
			#size (must be multiple of 4096)
			end_ramg_address - first_unused_ramg_address
		]
		self.send_command(command_list)
		#update the ring buffer pointer so the coprocessor starts executing
		self.update_fifo()
		#remember that the flash sector 0 is used
		#*Flash_Sector = 1; !!!!!!!!!!!!!
		#now wait for the coprocessor to catch up
		self.fifo_wait_until_empty()

##########################################################################################

	#Goodix GT911 init code for EVE
	#Magic binary data from "AN_336 FT8xx - Selecting an LCD Display"
	GOODIX_INIT_DATA = (
	0x1A,0xFF,0xFF,0xFF,0x20,0x20,0x30,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	0x22,0xFF,0xFF,0xFF,0x00,0xB0,0x30,0x00,0x78,0xDA,0xED,0x54,0xDD,0x6F,0x54,0x45,
	0x14,0x3F,0x33,0xB3,0x5D,0xA0,0x94,0x65,0x6F,0x4C,0x05,0x2C,0x8D,0x7B,0x6F,0xA1,
	0x0B,0xDB,0x9A,0x10,0x09,0x10,0x11,0xE5,0x9C,0x4B,0x1A,0x0B,0x0D,0x15,0xE3,0x03,
	0x10,0xFC,0xB8,0xB3,0x2D,0xDB,0x8F,0x2D,0x29,0x7D,0x90,0x48,0x43,0x64,0x96,0x47,
	0xBD,0x71,0x12,0x24,0x11,0xA5,0x64,0xA5,0xC6,0x10,0x20,0x11,0x95,0xC4,0xF0,0x80,
	0xA1,0x10,0xA4,0x26,0x36,0xF0,0x00,0xD1,0x48,0x82,0x0F,0x26,0x7D,0x30,0x42,0x52,
	0x1E,0x4C,0x13,0x1F,0xAC,0x67,0x2E,0x8B,0x18,0xFF,0x04,0xE3,0x9D,0xCC,0x9C,0x33,
	0x73,0x66,0xCE,0xE7,0xEF,0xDC,0x05,0xAA,0x5E,0x81,0x89,0x4B,0xC2,0xD8,0x62,0x5E,
	0x67,0x75,0x73,0x79,0x4C,0x83,0xB1,0x7D,0x59,0x7D,0x52,0x7B,0x3C,0xF3,0x3A,0x8E,
	0xF2,0xCC,0xB9,0xF3,0xBC,0x76,0x9C,0xE3,0x9B,0xCB,0xEE,0xEE,0xC3,0xFB,0xCD,0xE5,
	0x47,0x5C,0x1C,0xA9,0xBE,0xB8,0x54,0x8F,0x71,0x89,0x35,0xF4,0x67,0xB5,0xED,0x57,
	0xFD,0x71,0x89,0xE9,0x30,0x0C,0xC6,0xA5,0xB5,0x68,0x8B,0x19,0x54,0xFD,0x9B,0x72,
	0x4A,0xBF,0x00,0x36,0x8A,0xA3,0x0C,0x3E,0x83,0xCF,0x81,0x17,0xD9,0x22,0x5B,0x1F,
	0x80,0x41,0xF6,0xA3,0xAF,0xD5,0x08,0x93,0xD5,0x6B,0x23,0xCB,0x5E,0x6C,0x03,0x6F,
	0x28,0xAB,0x53,0x18,0x0F,0xA5,0xB1,0xDE,0x74,0x61,0x17,0xBC,0x8C,0xCE,0x96,0x2A,
	0x66,0xB5,0x57,0x4E,0x56,0xB6,0xAA,0x86,0xD7,0xF1,0x79,0x1A,0xF3,0xFC,0x02,0x4C,
	0x73,0xD9,0x8B,0xDE,0xCE,0xAD,0x88,0x84,0x51,0x3D,0x23,0xB9,0x27,0x71,0x17,0x2E,
	0xC7,0x4C,0xB2,0x36,0x97,0xB7,0xE0,0x00,0x28,0xBD,0x1C,0x95,0xB6,0x3A,0x83,0x4F,
	0x98,0x1E,0x4C,0x22,0x62,0xEA,0xA2,0xD8,0x85,0x8D,0x66,0x27,0xAA,0x28,0xC0,0x65,
	0x35,0xC9,0x92,0xBF,0x25,0x4D,0x2C,0xB1,0xD1,0x4A,0xD3,0x05,0xCE,0xBB,0x05,0x06,
	0xD8,0x2F,0x35,0x60,0x7B,0x16,0x32,0x67,0xFB,0xC0,0x54,0x11,0x4A,0xE3,0xB9,0x38,
	0x6A,0x33,0x5B,0xA1,0x60,0xB6,0xA3,0x30,0xAB,0x8D,0x8B,0x41,0x98,0x42,0x42,0x0B,
	0x66,0x2B,0x9E,0x4B,0x24,0x50,0x93,0xB8,0x93,0x8B,0x70,0x11,0xEB,0xD8,0x67,0x6F,
	0xEF,0xF5,0x5C,0x0A,0xAF,0xC2,0x28,0x2C,0x3A,0x7D,0x05,0x3B,0x70,0x32,0x67,0xF5,
	0x04,0x4E,0xC0,0x05,0x9C,0xC2,0x33,0x3C,0xBF,0x86,0x4B,0x6E,0xAD,0xED,0x2E,0xC0,
	0x79,0x9C,0xC0,0x73,0xB8,0xDA,0x78,0x43,0x3F,0x73,0x2E,0x0B,0x66,0x0A,0x61,0xE8,
	0x32,0xEB,0x72,0xB6,0x94,0x76,0xB2,0x29,0xBC,0x0C,0x87,0x4D,0xCA,0x7C,0x0C,0x60,
	0xEE,0x23,0xA1,0xEA,0xBD,0x81,0x17,0xF9,0xD4,0x8B,0xE6,0x19,0x35,0x30,0xCD,0x34,
	0x5D,0xA3,0x75,0x35,0x9A,0xAA,0x51,0x55,0xA3,0xB2,0x46,0x45,0x42,0xA7,0xF1,0x0E,
	0x2E,0xF1,0x01,0xE2,0x88,0x98,0xB3,0xC5,0x3B,0xB8,0x94,0xFE,0x31,0x84,0x30,0x0F,
	0xB0,0x89,0xC0,0x4C,0x83,0xC4,0x69,0x68,0xA2,0x56,0x51,0xA0,0xA5,0xFF,0x1A,0xAD,
	0xA2,0x89,0x56,0x91,0xD2,0xB7,0xC0,0x37,0xAF,0xC2,0xD3,0x3C,0x5B,0x78,0xE6,0xB8,
	0xAE,0x1B,0x29,0x83,0x9B,0x28,0xE0,0x1D,0x57,0xB3,0xE8,0x10,0x37,0x37,0x07,0xA5,
	0x93,0x51,0x17,0xA5,0x31,0x65,0x36,0xE0,0x4B,0xB4,0x51,0x6C,0x12,0x1D,0xE2,0x45,
	0xE1,0x6E,0xAF,0xE0,0x2A,0xD4,0x19,0x2F,0x82,0xC1,0x6E,0xEA,0xC0,0xD7,0xFC,0x38,
	0x4A,0xA2,0x18,0x2E,0xFB,0xAE,0x36,0x6A,0x44,0xF5,0x0E,0x09,0x9B,0xA0,0x16,0x78,
	0xCF,0x68,0xF0,0x1D,0x5A,0xB2,0x8C,0x1C,0x18,0xDC,0x2F,0xA6,0x70,0x3D,0xFB,0xD0,
	0xC0,0x6F,0x38,0xEF,0xEE,0x5D,0xFF,0xFB,0x3E,0x63,0x20,0xC1,0x4B,0x3D,0xBE,0xEB,
	0x7B,0xE5,0x6E,0xDA,0xC2,0x55,0x4F,0xE1,0x3B,0x62,0x14,0xEE,0xE3,0xEB,0xDC,0x0B,
	0xDD,0x95,0x19,0xB4,0x74,0xC2,0x9F,0x6F,0x60,0xC0,0x18,0xD5,0x3B,0x8B,0xB3,0x9C,
	0xD7,0x45,0xE6,0x13,0x18,0x23,0x87,0x75,0xCE,0xAB,0xCE,0xA2,0x43,0x81,0xEA,0x3D,
	0xEB,0x0B,0x68,0x67,0x54,0x40,0xDF,0xA7,0xFE,0x28,0xA3,0x65,0x5C,0x54,0x2B,0x96,
	0x2E,0xF9,0xDB,0xCD,0x07,0x74,0x0B,0x5B,0x68,0x3D,0x39,0x4B,0xDF,0x08,0x30,0x19,
	0x1C,0x77,0xFC,0xDE,0x71,0x31,0x56,0xF9,0x4A,0xB4,0xD3,0x9C,0xB5,0x3D,0xD7,0xA8,
	0x9D,0x07,0xFB,0xC7,0x96,0xF2,0xFA,0x5B,0x3A,0x84,0x5E,0x79,0x07,0x35,0x97,0x8B,
	0x62,0x06,0xA5,0x99,0x45,0xD6,0x20,0x6E,0xD3,0x64,0x65,0x1F,0x59,0x2D,0x51,0x62,
	0x17,0xCD,0xCD,0xC5,0xD1,0x6D,0xBA,0xC6,0x23,0x8D,0xBF,0xF9,0x19,0x3C,0x84,0xDF,
	0x99,0xFB,0x62,0x14,0xEF,0x92,0x8B,0x14,0xD9,0xFA,0x29,0xFA,0x89,0x3A,0xB1,0x5A,
	0x39,0x4F,0x33,0x6C,0xE9,0x14,0xFD,0xC2,0xBB,0x31,0xDE,0xCD,0x72,0x8D,0x60,0x30,
	0xAF,0xDB,0x6B,0x36,0x6F,0x8A,0x16,0x9A,0x67,0x6C,0x4F,0x3A,0xFC,0xB3,0xB2,0x4F,
	0xA4,0xC3,0x02,0x99,0x24,0x27,0xAA,0xC7,0xC9,0xA7,0xC5,0x55,0x6A,0x08,0x3B,0xB1,
	0x51,0x2E,0x38,0x02,0xE6,0x4B,0x72,0x11,0x37,0x70,0xBC,0x41,0xD0,0x89,0x4D,0x72,
	0x0A,0x73,0x37,0x3A,0xD0,0xC5,0xAD,0x7A,0x57,0x06,0x8C,0x6E,0x2A,0xD0,0x7C,0xA3,
	0x46,0x6C,0xF1,0x68,0x12,0xF5,0x62,0xD6,0xBB,0x86,0x35,0x2A,0xDD,0x16,0xB6,0x85,
	0xD3,0x74,0x94,0xB1,0xC2,0xD1,0xC0,0x55,0x5A,0xC7,0x3A,0x37,0xCB,0x02,0xE5,0x13,
	0x89,0xBB,0xA1,0xE4,0x9A,0x70,0xCB,0x91,0x7D,0xF4,0xBC,0xDC,0x76,0xE4,0x29,0xC9,
	0xB5,0x29,0xC3,0x90,0xD7,0xB7,0x33,0x50,0xFA,0x15,0xD9,0x10,0xD9,0xC8,0xEB,0x6D,
	0xE3,0xBC,0x7A,0xDA,0x8E,0x3C,0xAA,0xE0,0x70,0xF0,0xB8,0x82,0xE5,0xE0,0x71,0x05,
	0xDF,0x94,0xA3,0x50,0xA5,0xB7,0x82,0xBB,0x84,0x74,0x40,0xEE,0xA1,0x55,0xDC,0x73,
	0x8B,0xCD,0x62,0xE3,0xF4,0x1D,0x66,0x7D,0x07,0x25,0xF3,0x7B,0xDF,0x0B,0x1A,0x5C,
	0x3F,0xF3,0x74,0x3D,0xBF,0x8A,0x7B,0xF4,0xA0,0x54,0xBA,0x4A,0x1F,0x05,0xAE,0xF7,
	0x77,0x87,0xC7,0xF8,0xFD,0x87,0xF2,0x61,0x66,0x91,0xBE,0x90,0x0E,0x55,0xEE,0xDD,
	0xE7,0xC1,0x9E,0x30,0xCD,0x19,0x78,0xF8,0x0F,0xDC,0x1D,0x9E,0x09,0x46,0xB9,0x1E,
	0x67,0xE5,0x21,0xFE,0x17,0xED,0xA0,0xAC,0x3E,0xC1,0x5A,0xDE,0xE0,0xE8,0x0E,0xC8,
	0x38,0x5A,0x68,0x8E,0xE3,0x78,0x6E,0x06,0x15,0xD3,0xCB,0x41,0x96,0x63,0x97,0xDC,
	0xF7,0x57,0xA4,0x32,0x9F,0x31,0xEF,0xEA,0x3A,0x8E,0x00,0x6D,0x6C,0x7B,0x12,0x4F,
	0xE3,0x24,0x64,0xF8,0xDE,0xCD,0x60,0x7F,0x78,0x1A,0xAB,0xE4,0x45,0x3F,0x24,0x11,
	0xFC,0xC8,0x11,0x74,0xF2,0xBB,0xE3,0x58,0x8F,0xF7,0x02,0x4B,0xBF,0x06,0x82,0x3B,
	0xBC,0x0B,0x37,0xF0,0x1F,0xF3,0x7A,0x98,0xE2,0xB7,0xCF,0x9A,0x49,0xBC,0x27,0xDB,
	0x2B,0x69,0xDE,0x57,0x29,0x8F,0x8D,0x8C,0xAF,0x49,0x70,0xB8,0xFC,0x3D,0xB8,0x10,
	0x5A,0xFA,0x23,0xA8,0x52,0x77,0xB0,0x39,0x74,0x5E,0xC8,0x96,0x16,0xBE,0xB3,0x2C,
	0x68,0x0C,0xEB,0x54,0x95,0x66,0xFC,0x59,0x9A,0xC1,0x63,0xE4,0x6A,0xF2,0x7D,0xF8,
	0x40,0xC2,0xFF,0xDF,0x7F,0xF2,0x53,0x0B,0xFF,0x02,0x46,0xD6,0xE2,0x80,0x00,0x00,
	0x1A,0xFF,0xFF,0xFF,0x14,0x21,0x30,0x00,0x04,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,
	0x1A,0xFF,0xFF,0xFF,0x20,0x20,0x30,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00)

	def init_gt911(self):
		# function sets up address, writes the data blob, and executes
		"""
		Gpu_Hal_WrCmdBufFromFlash(phost, Goodix_GT911_Init_Data, GOODIX_GT911_INIT_DATA_LENGTH);

		//"Straight AN_336"
		//"Hold the touch engine in reset (write REG_CPURESET=2)"
		Gpu_Hal_Wr8(phost, REG_CPURESET, 0x02);

		//"Write REG_TOUCH_CONFIG=0x05D0"
		Gpu_Hal_Wr16(phost, REG_TOUCH_CONFIG, 0x05D0);

		//"Set GPIO0 output LOW"
		// The CFA10100 FT813 uses GPIO3 to reset GT911
		// Reset-Value is 0x8000 adding 0x0008 sets GPIO3 to output
		// Default-value for REG_GPIOX is 0x8000 -> Low output on GPIO3
		Gpu_Hal_Wr16(phost,REG_GPIOX_DIR,0x8008);
		// "Wait more than 100us"
		delay(1);
		// "Write REG_CPURESET=0"
		Gpu_Hal_Wr8(phost,REG_CPURESET, 0x00);
		// "Wait more than 55ms"
		delay(56);
		// "Set GPIO0 to input (floating)"
		// The CFA10100 FT813 uses GPIO3 to reset GT911
		Gpu_Hal_Wr16(phost,REG_GPIOX_DIR,0x8000);

		//done
		}
		"""
		pass